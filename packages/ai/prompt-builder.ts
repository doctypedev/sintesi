/**
 * Prompt engineering for AI-generated documentation
 */

import { DocumentationRequest, GenerateOptions } from './types';

/**
 * Builds prompts for AI providers to generate documentation
 */
export class PromptBuilder {
  /**
   * Generate a system prompt for documentation generation
   */
  static buildSystemPrompt(): string {
    return `You are a technical documentation expert specializing in TypeScript/JavaScript code documentation.

Your task is to generate clear, concise, and accurate documentation for code based on signature changes.

Guidelines:
- Write in Markdown format
- Be concise but comprehensive
- Focus on what changed and why it matters
- Include parameter descriptions with types
- Include return type descriptions
- Add usage examples when helpful
- Use proper Markdown formatting (headers, code blocks, lists)
- Maintain a professional, neutral tone
- Do NOT include meta-commentary about the documentation itself
- Do NOT add phrases like "This documentation was generated by AI"

Format the response as clean Markdown ready for injection into documentation files.`;
  }

  /**
   * Build a user prompt for documentation generation
   */
  static buildUserPrompt(request: DocumentationRequest, options: GenerateOptions = {}): string {
    const {
      symbolName,
      oldSignature,
      newSignature,
      oldDocumentation,
      context,
    } = request;

    const { includeContext = true, includeExamples = true, style = 'detailed' } = options;

    // Build the prompt sections
    const sections: string[] = [];

    // Header
    sections.push(`# Documentation Update Request`);
    sections.push('');
    sections.push(`Update the documentation for the symbol: **${symbolName}**`);
    sections.push('');

    // Old signature
    sections.push(`## Previous Signature`);
    sections.push('```typescript');
    sections.push(oldSignature.signatureText);
    sections.push('```');
    sections.push('');

    // New signature
    sections.push(`## New Signature (Current)`);
    sections.push('```typescript');
    sections.push(newSignature.signatureText);
    sections.push('```');
    sections.push('');

    // Old documentation
    if (oldDocumentation.trim()) {
      sections.push(`## Previous Documentation`);
      sections.push('');
      sections.push(oldDocumentation);
      sections.push('');
    }

    // Context (if available and requested)
    if (includeContext && context) {
      if (context.filePath) {
        sections.push(`## File Location`);
        sections.push(`\`${context.filePath}\``);
        sections.push('');
      }

      if (context.surroundingCode) {
        sections.push(`## Surrounding Code Context`);
        sections.push('```typescript');
        sections.push(context.surroundingCode);
        sections.push('```');
        sections.push('');
      }

      if (context.relatedSymbols && context.relatedSymbols.length > 0) {
        sections.push(`## Related Symbols`);
        context.relatedSymbols.forEach(symbol => {
          sections.push(`- \`${symbol}\``);
        });
        sections.push('');
      }
    }

    // Instructions
    sections.push(`## Instructions`);
    sections.push('');
    sections.push('Generate updated documentation that:');
    sections.push('1. Accurately reflects the new signature');
    sections.push('2. Explains the purpose and behavior of the code');
    sections.push('3. Documents all parameters with their types');
    sections.push('4. Documents the return type and what it represents');

    if (includeExamples) {
      sections.push('5. Includes a practical usage example');
    }

    if (style === 'concise') {
      sections.push('6. Is brief and to-the-point (maximum 200 words)');
    } else if (style === 'detailed') {
      sections.push('6. Is comprehensive but clear');
    } else if (style === 'tutorial') {
      sections.push('6. Is tutorial-style with step-by-step explanations');
    }

    sections.push('');
    sections.push('Generate **only** the documentation content in Markdown format. Do not include any preamble, meta-commentary, or explanations about the documentation itself.');

    return sections.join('\n');
  }

  /**
   * Build a simplified prompt for initial documentation (no previous docs)
   */
  static buildInitialPrompt(symbolName: string, signature: string, options: GenerateOptions = {}): string {
    const { includeExamples = true, style = 'detailed' } = options;

    const sections: string[] = [];

    sections.push(`# Generate Documentation`);
    sections.push('');
    sections.push(`Generate documentation for: **${symbolName}**`);
    sections.push('');
    sections.push(`## Signature`);
    sections.push('```typescript');
    sections.push(signature);
    sections.push('```');
    sections.push('');
    sections.push(`## Instructions`);
    sections.push('');
    sections.push('Generate documentation that:');
    sections.push('1. Explains the purpose and behavior');
    sections.push('2. Documents all parameters with types');
    sections.push('3. Documents the return type');

    if (includeExamples) {
      sections.push('4. Includes a usage example');
    }

    if (style === 'concise') {
      sections.push('5. Is brief (maximum 200 words)');
    } else if (style === 'detailed') {
      sections.push('5. Is comprehensive but clear');
    }

    sections.push('');
    sections.push('Generate **only** the Markdown documentation content.');

    return sections.join('\n');
  }

  /**
   * Extract the main changes between two signatures
   */
  static summarizeChanges(oldSignature: string, newSignature: string): string {
    const changes: string[] = [];

    // Simple heuristic-based change detection
    if (oldSignature.includes('function') && newSignature.includes('function')) {
      // Check parameter changes
      const oldParams = this.extractParameters(oldSignature);
      const newParams = this.extractParameters(newSignature);

      if (oldParams !== newParams) {
        changes.push('Parameters have changed');
      }
    }

    // Check return type changes
    const oldReturn = this.extractReturnType(oldSignature);
    const newReturn = this.extractReturnType(newSignature);

    if (oldReturn !== newReturn) {
      changes.push('Return type has changed');
    }

    if (changes.length === 0) {
      changes.push('Signature has been modified');
    }

    return changes.join(', ');
  }

  /**
   * Extract parameters from a TypeScript signature (simple regex)
   */
  private static extractParameters(signature: string): string {
    const match = signature.match(/\((.*?)\)/);
    return match ? match[1] : '';
  }

  /**
   * Extract return type from a TypeScript signature (simple regex)
   */
  private static extractReturnType(signature: string): string {
    const match = signature.match(/:\s*([^{;]+)/);
    return match ? match[1].trim() : '';
  }
}
