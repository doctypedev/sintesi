/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 *
 * Core type definitions for Doctype

 *
 * Reference to a code symbol in the source code

 */
export interface CodeRef {
  /** Absolute path to the source file */
  filePath: string;
  /** Name of the symbol (function, class, interface, etc.) */
  symbolName: string;
}
/**
 * Signature information extracted from code
 */
export interface CodeSignature {
  /** Name of the symbol */
  symbolName: string;
  /** Type of the symbol (function, class, interface, type, etc.) */
  symbolType: SymbolType;
  /** The actual signature text (normalized) */
  signatureText: string;
  /** Whether the symbol is exported */
  isExported: boolean;
  /** SHA256 hash of the signature (computed by Rust analyzer) */
  hash?: string;
}
/**
 * Types of symbols we track
 */
export const enum SymbolType {
  Function = "Function",
  Class = "Class",
  Interface = "Interface",
  TypeAlias = "TypeAlias",
  Enum = "Enum",
  Variable = "Variable",
  Const = "Const",
}
/**
 * Hash information for a code signature
 */
export interface SignatureHash {
  /** SHA256 hash of the signature */
  hash: string;
  /** Original signature that was hashed */
  signature: CodeSignature;
  /** Timestamp when hash was generated (milliseconds since Unix epoch) */
  timestamp: number;
}
/**
 * Reference to documentation location
 */
export interface DocRef {
  /** Path to the markdown file */
  filePath: string;
}
/**
 * Complete mapping entry in doctype-map.json
 *
 * Note: Content is not stored here to avoid duplication.
 * The markdown file is the single source of truth for content.
 * Use the anchor ID to locate content between doctype:start and doctype:end tags.
 */
export interface DoctypeMapEntry {
  /** Unique identifier for this anchor */
  id: string;
  /** Reference to the code */
  codeRef: CodeRef;
  /** Hash of the code signature */
  codeSignatureHash: string;
  /** The signature text (for AI context) */
  codeSignatureText?: string;
  /** Reference to the documentation */
  docRef: DocRef;
  /** Last updated timestamp */
  lastUpdated: number;
}
/**
 * The complete doctype-map.json structure
 */
export interface DoctypeMap {
  /** Schema version for future compatibility */
  version: string;
  /** All tracked documentation anchors */
  entries: Array<DoctypeMapEntry>;
}
/** Analysis result including errors (for NAPI) */
export interface AnalysisResultJs {
  /** All code signatures found */
  signatures: Array<CodeSignature>;
  /** Errors encountered during parsing */
  errors: Array<string>;
}
/** NAPI-compatible result structure for file discovery */
export interface FileDiscoveryResult {
  /** List of markdown file paths found */
  markdownFiles: Array<string>;
  /** List of source file paths found */
  sourceFiles: Array<string>;
  /** Total number of files found */
  totalFiles: number;
  /** Number of errors encountered */
  errors: number;
}
/** NAPI-compatible options for file discovery */
export interface FileDiscoveryOptions {
  /** Respect .gitignore rules (default: true) */
  respectGitignore?: boolean;
  /** Include hidden files (default: false) */
  includeHidden?: boolean;
  /** Maximum depth to traverse (default: unlimited) */
  maxDepth?: number;
}
/**
 * Discover files in a directory (NAPI binding for Node.js)
 *
 * Scans the given directory and returns all markdown and source files found.
 * Respects .gitignore by default.
 *
 * # Arguments
 * * `root_path` - The root directory to scan
 * * `options` - Optional configuration for the discovery process
 *
 * # Example (Node.js)
 * ```javascript
 * const { discoverFiles } = require('@doctypedev/core');
 *
 * const result = discoverFiles('./src', {
 *   respectGitignore: true,
 *   includeHidden: false,
 *   maxDepth: 5
 * });
 *
 * console.log('Found', result.markdownFiles.length, 'markdown files');
 * console.log('Found', result.sourceFiles.length, 'source files');
 * console.log('Total:', result.totalFiles);
 * ```
 */
export declare function discoverFiles(
  rootPath: string,
  options?: FileDiscoveryOptions | undefined | null,
): FileDiscoveryResult;
/** NAPI-compatible doctype anchor structure */
export interface DoctypeAnchor {
  /** Unique anchor ID */
  id: string;
  /** Code reference (e.g., "src/auth.ts#login") */
  codeRef?: string;
  /** File path where anchor was found */
  filePath: string;
  /** Start line number (0-indexed) */
  startLine: number;
  /** End line number (0-indexed) */
  endLine: number;
  /** Content between anchor tags */
  content: string;
}
/** NAPI-compatible extraction result */
export interface ExtractionResult {
  /** Map of anchor ID to anchor data (as a flat array for NAPI compatibility) */
  anchors: Array<DoctypeAnchor>;
  /** Number of anchors found */
  anchorCount: number;
  /** Errors encountered during extraction */
  errors: Array<string>;
}
/**
 * Extract doctype anchors from markdown content
 *
 * # Arguments
 * * `file_path` - Path to the markdown file (for reference)
 * * `content` - Markdown content to parse
 *
 * # Returns
 * ExtractionResult with all found anchors and any errors
 *
 * # Example (Node.js)
 * ```javascript
 * const { extractAnchors } = require('@doctypedev/core');
 *
 * const content = fs.readFileSync('docs/api.md', 'utf-8');
 * const result = extractAnchors('docs/api.md', content);
 *
 * console.log('Found', result.anchorCount, 'anchors');
 *
 * for (const anchor of result.anchors) {
 *   console.log('Anchor:', anchor.id);
 *   console.log('  Code ref:', anchor.codeRef);
 *   console.log('  Lines:', anchor.startLine, '-', anchor.endLine);
 * }
 *
 * if (result.errors.length > 0) {
 *   console.error('Errors:', result.errors);
 * }
 * ```
 */
export declare function extractAnchors(
  filePath: string,
  content: string,
): ExtractionResult;
/**
 * Validate markdown content for doctype anchors
 *
 * This performs validation without extracting content, making it faster
 * for checking if markdown is valid.
 *
 * # Arguments
 * * `content` - Markdown content to validate
 *
 * # Returns
 * Array of validation error messages, empty if valid
 *
 * # Example (Node.js)
 * ```javascript
 * const { validateMarkdownAnchors } = require('@doctypedev/core');
 *
 * const content = fs.readFileSync('docs/api.md', 'utf-8');
 * const errors = validateMarkdownAnchors(content);
 *
 * if (errors.length === 0) {
 *   console.log('✓ All anchors are valid');
 * } else {
 *   console.error('⚠ Validation errors:');
 *   errors.forEach(err => console.error('  -', err));
 * }
 * ```
 */
export declare function validateMarkdownAnchors(content: string): Array<string>;
/**
 * Parse a code_ref string into file path and symbol name
 *
 * # Arguments
 * * `code_ref` - Code reference string (format: "file_path#symbol_name")
 *
 * # Returns
 * Object with filePath and symbolName properties
 *
 * # Throws
 * Error if the code_ref format is invalid
 *
 * # Example (Node.js)
 * ```javascript
 * const { parseCodeRef } = require('@doctypedev/core');
 *
 * const { filePath, symbolName } = parseCodeRef('src/auth.ts#login');
 * console.log('File:', filePath);    // "src/auth.ts"
 * console.log('Symbol:', symbolName); // "login"
 * ```
 */
export interface CodeRefParts {
  filePath: string;
  symbolName: string;
}
export declare function parseCodeRef(codeRef: string): CodeRefParts;
/** Simple hello world function to test the napi binding */
export declare function helloWorld(): string;
/** Get version information */
export declare function getVersion(): string;
/** AST Analyzer for TypeScript/JavaScript code */
export declare class AstAnalyzer {
  /** Create a new AST analyzer instance */
  constructor();
  /**
   * Analyze a TypeScript/JavaScript file and return code signatures
   *
   * This method reads the file, parses it using Oxc, and extracts all
   * exported symbols with their signatures. Hashes are computed automatically.
   *
   * @param filePath - Absolute path to the TypeScript/JavaScript file
   * @returns Array of code signatures found in the file (with hashes)
   */
  analyzeFile(filePath: string): Array<CodeSignature>;
  /**
   * Analyze TypeScript/JavaScript source code directly (without file)
   *
   * This method parses the provided code string using Oxc and extracts all
   * exported symbols with their signatures. Hashes are computed automatically.
   *
   * @param code - TypeScript/JavaScript source code
   * @returns Array of code signatures found in the code (with hashes)
   */
  analyzeCode(code: string): Array<CodeSignature>;
  /**
   * Get detailed analysis result including errors
   *
   * @param code - TypeScript/JavaScript source code
   * @returns Detailed analysis result with symbols and errors (with hashes)
   */
  analyzeWithErrors(code: string): AnalysisResultJs;
}
